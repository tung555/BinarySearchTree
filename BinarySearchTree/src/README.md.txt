
-getSingleParent-
Conduct a in-order traversal and when it gets to the key, check if 
that node only has one child, if yes, print out the key. The big O 
complexity of this method is O(n).
Explanation: 
Recurrence relation: 2T(n-1) + 1
T(n) = O(n^(log2)) = O(n^1) = O(n)

-getNumLeafNodes-
I create a new variable for this function, int currentNumLeafNode, 
which to store the current number of leaf node at the time of calling 
the method. Conduct a in-order traversal then if a leaf node is traversed, 
add one to currentNumLeafNode. The big O complexity of this method is 
O(n).
Explanation:
Recurrence relation: 2T(n/2) + 1
T(n) = O(n^(log2)) = O(n^1) = O(n)

-getCousins-
First, after the user input the key number, call findLevel(int key), 
to find the level that the node is belonging. Because I need the level 
of the node to determine how many transitions (getLeft or getRight) 
I would need in order to reach the targeting node. My thought is, the 
cousins if a node in a BST will be all the nodes that could be reached 
from the root of the tree by calling the same times of the transitions, 
and exclude itself and its sibling node(if presented). For example, if a 
node is at level 3, then its cousins will be all the nodes that is 2 transitions 
away from the root, excluding itself and its sibling. In order to get all 
the cousins, I write getCousins in a recursive way which given the level 
"n" of the targeting node then generates all possible binary string of 
length n. Those binary strings can be generated by continuously assigning 
0 and 1 to index i in the array arr which has length n, the 0 in binary 
string is representing left, and 1 is representing right. Once arr is full, call 
findCousinsHelper which tries all the possible paths to get a cousins. assigning 
the returning value to the variable "cousin", then exclude self, sibling, and null.
If cousin is found, print it out, then continue to try the next possible path. 
Until all the possible paths have been tried. The big O complexity of this 
method is O(n*2^n).
Explanation:
Recurrence relation: 2T(n-1) + n
T(n) = O(n^d * a^(n/b)) = O(n^1*a^(n/1)) = O(n*2^n)
